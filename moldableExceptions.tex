% Modeled after sample-sigplan.tex
\documentclass[sigplan,anonymous,review,10pt]{acmart}
%\documentclass[sigplan,10pt]{acmart}
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}
\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}
%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Onward!]{Onward!}{Oct.\ 20-25, 2024}{Pasadena, CA}
\acmISBN{978-1-4503-XXXX-X/18/06}
% ============================================================
\input{macros}
\input{st80.tex}
% ============================================================
% Macros for this paper
%\renewcommand{\nbc}[3]{} % To hide reviewer comments
\newcommand\on[1]{\nbc{ON}{#1}{olive}} % add more author macros here
\newcommand\tg[1]{\nbc{TG}{#1}{blue}}
\newcommand\ac[1]{\nbc{AC}{#1}{teal}}
%\newcommand\XXX[1]{\nbc{XXX}{#1}{red}}
%\newcommand\XXX[1]{\nbc{XXX}{#1}{violet}}
\usepackage{caption}
\captionsetup{aboveskip=5pt,belowskip=-10pt} % Adjust the space around figure captions
%\usepackage{enumitem}
%\setlist[description]{font=\itshape}
\newcommand{\GT}{\lst{GT}\xspace} % In case we want to display it differently ...
\newcommand\lmaf{\lst{Ludo\-Move\-Assert\-ion\-Fail\-ure}\xspace}
% ============================================================
% Optionally anonymize selected names
\newboolean{anonymous}
\setboolean{anonymous}{true}
\newcommand\anonymize[2]{\ifthenelse{\boolean{anonymous}}{#2}{#1}\xspace}
\newcommand\feenk{\anonymize{feenk}{anonymous company}}
\newcommand\deet{{\tt deet}\xspace}
% ============================================================
\begin{document}
\title{Moldable Exceptions}
\author{Andrei Chi\c{s}}
\affiliation{%
  \institution{feenk gmbh}
  \city{Wabern}
  \country{Switzerland}}
\email{andrei.chis@feenk.com}
\author{Tudor G\^irba}
\affiliation{%
  \institution{feenk gmbh}
  \city{Wabern}
  \country{Switzerland}}
\email{tudor.girba@feenk.com}
\author{Oscar Nierstrasz}
\affiliation{%
  \institution{feenk gmbh}
  \city{Wabern}
  \country{Switzerland}}
\email{oscar.nierstrasz@feenk.com}

\renewcommand{\shortauthors}{Chi\c{s} et al.}

\begin{abstract}
Debugging is hard.
Debuggers are mostly the same.
They show you a stack, a way to sample the state of the stack, and, if the debugger is live, a way to step through execution.
The standard debugger mostly offers a clumsy, low-level interface to track down and fix bugs.
A custom debugger, such as those developed for specific application domains, offers alternative interfaces more suitable to the specific execution context of the program being debugged.
% In contrast, a ``moldable debugger'' offers alternative interfaces based on the current execution context.
% In contrast, moldable debuggers change based on the context of the stack.
Contextual debugging views and actions greatly improve our ability to reason about the current problem.
Implementing such custom debuggers, however, is non-trivial, and poses a barrier to improving the debugging experience.
% Still, creating custom debuggers is much less trivial than extending an inspector with custom views and actions.
In this paper we introduce \emph{moldable exceptions}, a lightweight mechanism to adapt a debugger's interface based on contextual information provided by a raised exception.
% In this paper, we introduce a lightweight mechanism centered around exceptions to create custom debugging views and actions: as exceptions hold the entire necessary debugging context, extending the debugger can be as easy as extending the inspector of an exception.
%Moldable exceptions offer a lightweight mechanism to adapt a moldable debugger to the specific context of the exception raised to show more useful views and actions to a developer.
We present, through a series of examples, how moldable exceptions can enhance a live programming environment.
\end{abstract}

\keywords{Exceptions, debuggers, customization.}

%\received{20 February 2007}
%\received[revised]{12 March 2009}
%\received[accepted]{5 June 2009}

\maketitle

% ============================================================
\section{Introduction}\label{sec:intro}

In the bad old days, all debuggers were the same.
You had commands to sample the current execution state, and you had commands to step through the running code.
Nowadays we have graphical debuggers that show us the run-time stack, and offer buttons instead of commands to step through the code, but they are still all the same.
The trouble with this is that every debugging problem is different, but debuggers all show us the same thing.

There have been numerous efforts to develop custom debuggers for various application domains and domain-specific languages.
These custom debuggers provide dedicated views and actions that are tailored to a specific application context.
Building a custom debugger is, however, a non-trivial task, so this doesn't happen too often.
An \emph{extensible} debugger (such as \deet~\cite{Hans97a}) is designed so that it can be easily extended with new graphical views and debugging operations, but these extensions still represent a significant development effort.
A \emph{moldable debugger}~\cite{Chis15c} is a special kind of extensible debugger that can activate alternative debugger interfaces depending on the current execution context, however the development of these alternative debuggers is still non-trivial.

%\ac{For the abstract/introduction we could emphasise more that even if it is currently possible to have multiple custom debuggers in GT/Pharo, the extension mechanism plays an important role.
%If the cost is high, the chances that developers will do it decreases.
%Maybe a good discussion here would be the extensions for views/searches/actions.
%There the extensions mechanism is different and we created many extensions.
%But even if the debugger is extensible we have only a few custom debuggers as the effort to create one is high.
%We will still need to have standalone debuggers with a higher cost to create in some cases (for example the SmaCC debugger), but in many cases we will benefit from being able to integrate views/actions in the debugger in an easier way.}

%\ac{In a way Moldable Exceptions augments the current extension mechanism for the debugger.
%In the current extension mechanism at each step in the execution we need to determine the list of available debuggers.
%For that we have multiple debuggers registered in the system, and we ask each debugger if it wants to handle the current context or not.
%With moldable exceptions in case we have also an exception in the current context we ask that exception to provide us with a list of of debugging views and actions to add to the current debugger and a list of new debugging interfaces.}

We propose a new, lightweight mechanism, called \emph{moldable exceptions}, to dynamically adapt a moldable debugger using contextual information provided by the exception itself.
In modern, object-oriented software, it is common practice to define dedicated classes of exceptions to signal individual run-time issues.
Each exception therefore implicitly carries knowledge about the kind of issue being raised.
Moldable exceptions leverage this knowledge by associating simple views and actions to be activated by a moldable debugger when that exception is raised.

Consider the following example.
In \autoref{fig:stringComparisonSnippet} we see an assertion that compares two strings.\footnote{All the examples are written in Pharo Smalltalk (\url{https://pharo.org}), running in the open-source Glamorous Toolkit IDE (\url{https://gtoolkit.com}).}
\begin{figure}[h]
  \includegraphics[width=\columnwidth]{stringComparisonSnippet}
  \caption{A failing string comparison assertion.}
  \label{fig:stringComparisonSnippet}
\end{figure}
In a normal setting, this assertion will fail, yielding a standard debugger view, as we see in \autoref{fig:genericDebugger}.
\begin{figure}[h]
  \includegraphics[width=\columnwidth]{genericDebugger}
  \caption{A generic debugger view.}
  \label{fig:genericDebugger}
\end{figure}
It will then take a developer some time to putter around in the debugger interface to understand the specific error (the strings don't match), and why the strings don't match.

Suppose that instead of seeing the generic debugger, we are offered a view that highlights the actual differences, as in \autoref{fig:stringComparisonView}.
\begin{figure}[h]
  \includegraphics[width=\columnwidth]{stringComparisonView}
  \caption{A string diff debugger view.}
  \label{fig:stringComparisonView}
\end{figure}
Such a view not only homes directly in on the specific problem, but also highlights the individual differences in a dedicated ``diff'' view.
Furthermore, since the diff view already exists as a component used in other applications, the development effort is close to zero.

Moldable exceptions work as follows: when an exception is raised, the exception (an object) is caught and passed to the debugger.
Every exception not only provides the debugger with the context it needs to generate the debugging UI, but it can also offer alternative views and actions.
In the case of our implementation, this is achieved by the exception class providing specially annotated debugger extension methods.

This simple mechanism allows moldable exceptions to do three things:
\begin{enumerate}[(i)]
	\item provide domain-specific debugging views and actions,
	\item offer new debugger GUI interactions, and
	\item enable automated fixes (code transformations) for common programming errors.
\end{enumerate}

We will illustrate these three points with numerous examples.
In \autoref{sec:views} we show how custom debugger views can easily be defined by adding simple annotated view methods to the class of a moldable exception.
In \autoref{sec:interactions} we show how a richer debugger interface can be provided in much the same way by leveraging existing GUI frameworks.
Finally we show an example of moldable exceptions enabling automated fixes in \autoref{sec:fixes}.
We summarize our contributions and discuss some possible future work in \autoref{sec:directions}, and we discuss related work in \autoref{sec:related}.
We conclude in \autoref{sec:conclusion}.

% ============================================================
\section{Adding custom debugger views}\label{sec:views}

Moldable exceptions build on and extend the notions of custom views and actions that can be used to extend a \emph{moldable object inspector}~\cite{Chis15a}.
When a moldable object inspector is opened on an object it looks for any view methods defined in the class of that object, and uses those methods to create custom views.
For example, in \autoref{fig:onwardUrlInspectorView} we see an inspector on a \st{ZnUrl} object.
Instead of just showing us the classical ``raw'' view of the object's instance variables, we see here one of several dedicated views providing detailed information about the URL.
\begin{figure}[t]
  \includegraphics[width=\columnwidth]{onwardUrlInspectorView}
  \includegraphics[width=\columnwidth]{onwardUrlInspectorViewSource}
  \caption{A moldable inspector view of a ZnUrl object and its source code.}
  \label{fig:onwardUrlInspectorView}
\end{figure}
Just below we see part of the source code defining this view.
These view methods are recognized by the moldable inspector through a dedicated annotation, in exactly the same way that a test runner tool in a classical IDE recognizes Java test case methods because they are tagged with a \st{@Test} annotation.
In this case the annotation is \st{<gtView>}, seen in the second line of the method.

Moldable exceptions provide custom debugger views and actions in essentially the same way.
Moldable exceptions are instances of an \emph{Exception} class that has been extended with a dedicated method for each each custom debugger view or action.
These methods are annotated with a \lst{<gt\-Exception\-Debugging\-View>} pragma.

Let's go through a typical example.
Suppose we have an implementation of a Ludo\footnote{A simple game in which players move tokens around a board based on the roll of a die.
\url{https://en.wikipedia.org/wiki/Ludo}} game implemented with the help of \emph{Design by Contract}~\cite{Meye92b}.
Players alternate in throwing a die and moving a token.
Rolling a die when when a player should move, or vice versa, constitutes a precondition violation, which raises a \st{LudoMoveAssertionFailure}.
Similarly, if an attempt is made to move the wrong player's token, this will trigger a precondition failure.
\begin{figure}[h]
  \includegraphics[width=\columnwidth]{ludoClassicDebugger}
  \caption{A classical debugger for a precondition failure.}
  \label{fig:ludoClassicDebugger}
\end{figure}
Normally, this would fire up the classical debugger, as seen in \autoref{fig:ludoClassicDebugger}.
Although the precondition violation is clearly reported, the debugger interface is not ideal for tracking down the actual reason for the violation.

What we would perhaps like to see instead is the current state of the game, in addition to a history of the past moves.
We could possibly find these by navigating through the existing debugger views, but why not show them directly?
After all, we know that whenever this exception is raised, what it is that we'd like to see.
Furthermore, if we already have such views defined elsewhere (we do!), it's not a question of defining new views, but of reusing them in the context of the debugger.
We just need to define two new view methods in the class \lmaf.

Here is the definition of the first view, which simply forwards (delegates) the view to another existing one.
\begin{code}
gtGameViewFor: aView
	<gtExceptionDebuggingView>
	^ aView forward
		title: 'Game';
		priority: 10;
		object: [ move game ];
		view: #gtPositionsFor:
\end{code}
Let's step through the code: \st{gtGameViewFor:} is the name of the view method, which takes as its argument \st{aView}, the view to be defined.
The method is annotated with \lst{<gtExceptionDebuggingView>}, which tells the moldable debugger to enable the view whenever \lmaf is raised.
We return (\st{^}) the result of sending \st{forward} to \st{aView}, giving the view a title and a priority (order in which views) appear, and we specify the object to forward to (the move's \st{game}) and the already existing view method to forward to (\st{gtPositionsFor:}).

We similarly define a method for the history of past moves, and now the debugger, instead of showing us the classical debugger, will offer us the two views seen in \autoref{fig:ludoCustomViews}.
\begin{figure}[h]
  \includegraphics[width=\columnwidth]{ludoView1-Game}
  \includegraphics[width=\columnwidth]{ludoView2-Moves}
  \caption{Custom debugger views for the Ludo game.}
  \label{fig:ludoCustomViews}
\end{figure}
The Game view shows us the current game state graphically, and the Moves view shows us a browsable list of past moves.
Note that we can always switch to the old debugger by selecting the \emph{GT Debugger} button at the top.

In \autoref{fig:ludoCustomViewsSource} we can see that the \emph{Moves} debugger view forwards to an existing Object Inspector view also called \emph{Moves}, but defined in the \st{GtLudoRecordingGame} class.
\begin{figure}[h]
  \includegraphics[width=\columnwidth]{ludoView2-Moves-Source}
  \caption{Browsing the source code of debugger views.}
  \label{fig:ludoCustomViewsSource}
\end{figure}
The existing inspector view uses just a few lines of code to create a browsable ``columned'' list of past moves with several columns for the details of each move.

The assertion diff debugger view we saw earlier in \autoref{fig:stringComparisonView} is similarly defined as a method of \st{AssertionFailure}.
\begin{code}
AssertionFailure>>gtTwoPanesStringDiffFor: aView
	<gtView>
	<gtExceptionDebuggingView>
	| assertionContext |
	self gtHasStack ifFalse: [ ^ aView empty ].
	assertionContext := self gtLocateAssertEqualsContextWithComparableTypes.
	assertionContext ifNil: [ ^ aView empty ].
	^ aView forward
		title: 'Textual Diff';
		priority: 0;
		object: [ assertionContext ];
		view: #gtTwoPanesStringDiffFor:
\end{code}
The key difference is that not every \st{AssertionFailure} is raised as the result of a string comparison.
For this reason, in lines $6-7$, the view will be suppressed (\st{^ aView empty}) in case the assertion did \emph{not} fail in the context of an \st{assert:equals:} check.

% ============================================================
\section{Providing domain-specific debugger interfaces}\label{sec:interactions}

The examples we have seen so far have reused existing inspector views, but sometimes there is a need to develop a new kind of debugger interface.
This also does not necessarily imply a heavy implementation effort.

Let us consider the case of assertion errors being raised while testing a user interface interaction with the help of a GUI ``Scripter'' object.
We introduce three dedicated debugger views.
The \emph{Scripter preview} (\autoref{fig:scripterPreview}) shows the result of a scripted interaction:
\begin{figure}[h]
  \includegraphics[width=\columnwidth]{scripterPreview}
  \caption{Scripter preview.}
  \label{fig:scripterPreview}
\end{figure}
\begin{inparaenum}[(i)]
	\item a notebook page has been created, containing a link to the class \st{Object}, and
	\item the link to the class has been clicked, opening a source code browser on the class.
\end{inparaenum}

The \emph{Scripter steps} view (\autoref{fig:scripterStepsViewClicked}) shows us a graphical tree view of the steps performed by the GUI Scripter, as well as the assertions that have been checked.
\begin{figure}[h]
  \includegraphics[width=\columnwidth]{scripterStepsViewClicked}
  \caption{Scripter steps view.}
  \label{fig:scripterStepsViewClicked}
\end{figure}
The green steps and assertions have succeeded, whereas the red ones have failed.
By clicking on any step or assertion node, we can see the corresponding code highlighted in the scripter method at the right.

Finally, the \emph{Textual Diff} view (\autoref{fig:scripterDiff}) is the same one we have seen earlier, reused again.
\begin{figure}[h]
  \includegraphics[width=\columnwidth]{scripterDiff}
  \caption{Scripter textual diff view.}
  \label{fig:scripterDiff}
\end{figure}
It just tells us that the check should verify that there are now two pages in the pager, not just one, as we can also see in the \emph{Scripter preview}.

\paragraph{Why do we need these views?}
The problem with the standard debugger is that, due to the way the GUI Scripter schedules the steps, the offending method (\ie the \lst{page\-With\-Class\-Clicked} method we see in \autoref{fig:scripterStepsViewClicked}) is \emph{not on the stack} (\autoref{fig:scripterClassicDebugger}) at the point where the exception is raised.
\begin{figure}[h]
  \includegraphics[width=\columnwidth]{scripterClassicDebugger}
  \caption{The trouble with the standard debugger.}
  \label{fig:scripterClassicDebugger}
\end{figure}
Although it is possible to get at the information we seek, it is clumsy, and the classical stack view only confuses matters instead of helping us to debug the problem.
This can be the case with many application domains, especially those that depend on event scheduling.
The run-time stack does not do a good job of telling you how the events have been triggered, so another kind of view is needed.

\paragraph{How hard is it to implement a domain-specific debugger interface?}
The \emph{Scripter steps view} is implemented using a version of \emph{Mondrian}~\cite{Pena13b,Meye06a}, a builder for graph-based visualizations.
In \autoref{fig:scripterStepsViewSource} we can see the entire source code of the view expanded in place, implemented in just four methods.
\begin{figure}[h]
  \includegraphics[width=\columnwidth]{scripterStepsViewSource}
  \caption{The Scripter steps source code.}
  \label{fig:scripterStepsViewSource}
\end{figure}
The debugging view at the top just adds a ``Inspect Scripter'' button to the next method, an object inspector view for a Scripter.
This in turn just delegates to the \emph{Steps} view of a \st{BlDevScripterStep} object.
Finally, this method embeds a Mondrian visualization implemented in 12 lines of code in the \st{paintTreeWith:} method.

% 14 LOC AssertionFailure>>#gtScripterStepsFor:
%  3 LOC BlScripter>>#gtStepsMondrianTreeFor:
%  8 LOC BlDevScripterStep>>#gtStepsMondrianTreeFor:
% 12 LOC BlDevScripterStep>>#paintTreeWith:
% TOTAL: 12 mondrian + 25 boilerplate

Obviously this does not prove that all domain-specific debugger interfaces will be so tiny, but it does demonstrate that a useful debugger extension can be implemented in an almost trivial amount of code.

% ============================================================
\section{Enabling automated fixes}\label{sec:fixes}

Many cases of common programming errors can be automatically repaired.
A good example of this is that of deprecated methods for which a well-defined alternative is available.
In Pharo Smalltalk this is achieved with the \st{#deprecated:transformWith:} message defined in the class \st{Object}.
It takes as arguments
\begin{inparaenum}[(i)]
	\item an explanatory string, and
	\item a source code transformation rule.
\end{inparaenum}    
We see an example below, where the method \st{ClassDescription>>definition} has been deprecated, and should be replaced by \st{definitionString} in client code.
While the \st{deprecated:} message normally spawns a Debugger, when a transformation rule is supplied, instead the client code is automatically rewritten, after which execution proceeds.
Here the transformation rule matches a send of \st{definition} for some receiver expression, and rewrites the message send to \st{definitionString}.

\begin{code}
ClassDescription>>definition
	"Answer a String that defines the receiver."
	self
		deprecated: #definition
		transformWith: '`@receiver definition' -> '`@receiver definitionString'.
	^ self definitionString
\end{code}

The fix is so straightforward, that it can be applied without any programmer intervention, or the need to spawn a debugger.
In \autoref{fig:deprecationDemo} we see the result of running client code of the old, deprecated method.
If we \emph{Play and Inspect} the method, we see that it is rewritten, and then directly evaluated.

\begin{figure}[h]
  \includegraphics[width=\columnwidth]{deprecationDemoBefore}
  \includegraphics[width=\columnwidth]{deprecationDemoAfter}
  \caption{Automatically rewriting a client of deprecated code, before and after.}
  \label{fig:deprecationDemo}
\end{figure}

Unfortunately the automated fix for deprecated methods is bespoke behavior.
Pharo offers no general mechanism for automatically fixing other kinds of simple programming errors.
Moldable exceptions, however, offer a more general solution.

Consider the case of a common programming error being that of providing to an API an object of the wrong type, or of the right type but the wrong state.
While the first kind of mistake could arguably be caught a static type system, detecting objects being in a wrong state is rather a run-time issue, typically caught by a precondition.
Some common cases can be fixed by rewriting the client code.
In \autoref{fig:emptyViewError} we see the source code for a custom inspector view that incorrectly returns \st{aView} instead of \st{aView empty} in the preamble.
This custom debugger view decorates the source code with an explanation pointing out the likely errors.

\begin{figure}[h]
  \includegraphics[width=\columnwidth]{emptyViewError}
  \caption{Catching an ``empty view'' error.}
  \label{fig:emptyViewError}
\end{figure}

Since such preambles are a common idiom in defining GT inspector views, and the error is also not uncommon, it becomes easy to fix with the help of a transformation.
\autoref{fig:emptyViewErrorFix} shows the result of performing the \emph{Fix it \& Proceed} action: a refactoring widget is generated that proposes a code transformation.
Clicking on the \emph{Apply refactoring and proceed} button will transform the source code, leave the debugger, and evaluate the rewritten code.

\begin{figure}[h]
  \includegraphics[width=\columnwidth]{emptyViewErrorFix}
  \caption{Tranmsforming an empty view error.}
  \label{fig:emptyViewErrorFix}
\end{figure}

A custom debugger action, such as \emph{Fix it \& Proceed} or \emph{Retry} is defined in the same way as a custom debugger view: it is method with a particular annotation, in this case it is \st{<gtPhlowSameViewReturnDebugAction>} rather than \mbox{\st{<gtExceptionDebuggingView>}}, but  the mechanism is essentially the same.

The default behavior of such fixits is to open a debugger with the possibility of applying a proposed code transformation.
If, on the other hand, such code transformations should be applied automatically, this can be configured.
In our proof-of-concept implementation of moldable exceptions, this is done by evaluation the following code, setting a flag in a globally accessible Singleton.

\begin{code}
GtMoldableExceptionTransformationsSettings defaultInstance allowAutomaticTransformations.
\end{code}

The \st{signal} method of exception classes can then optionally consult this flag to decide whether to spawn a debugger or apply the transformation.

As before, the custom debugger views and actions are mostly built from existing components, so the implementation effort is low.

\todo{Discuss the LifeWare tests?}

% ============================================================
\section{Discussion and future directions}\label{sec:directions}

Moldable exceptions are just objects augmented with annotated methods that create alternative views and actions when they are used to spawn a moldable debugger.
The cost of creating these views and actions can be very low.
At the time of writing we have implemented some 26 custom debugger views, with an average of under 12 lines of code.
Over half of the views forwarding views that reuse (delegate to) existing views previously defined as object inspector views.
Several more are simple text, list or tree views, and only three create custom graphical widgets.

The simplest debugging views are just like inspector views, and many of our examples just forward (delegate) to existing views, but more generally exceptions have access to the reified run-time stack at the time that they are raised, so debugger views can extract and present arbitrary run-time information.
The \emph{Scripter steps} view we saw earlier in \autoref{fig:scripterStepsViewClicked} offers an example.
The same approach could be used, for example, to present or highlight just the ``interesting'' stack frames, for example in an event-driven application, just the methods that are responsible for processing events.
\on{AC: can you perhaps provide a better or more detailed example?}

At this time, moldable exceptions only offer the possibility to provide alternative views and actions, but not alternative ways to step through the execution.
Currently this is only possible by providing a completely separate debugger implementation.
In \autoref{fig:smaccDebugger} we see such a dedicated debugger for SmaCC~\cite{Brant17a}, the Smalltalk compiler compiler framework that has been spawned on an invalid fragment of Java code.
The SmaCC debugger offers the possibility step through the grammar rules of a parser and explore its execution state.
\on{AC: is this something that we can foresee in the future? If so, what might it look like?}

\begin{figure}[h]
  \includegraphics[width=\columnwidth]{smaccDebugger}
  \caption{A custom SmaCC debugger on an invalid Java snippet.}
  \label{fig:smaccDebugger}
\end{figure}

Our proof-of-concept implementation of moldable exceptions present here heavily leverages the existing infrastructure for moldable inspector views, but in principle there is nothing to prevent its application to other programming languages and IDEs.
The basic idea is simple: any moldable tool must be prepared, whenever it is created, to examine the execution context of the objects it is initialized with, and use that context to adapt its behavior.
In the case of a moldable debugger, this context is provided by the exception raised.
Custom debugger views and actions must then be provided by the specific exception raised.
One way to provide such views and actions is by specially annotated methods, but other means could be used, such as a naming convention, or a registry of debugger extensions.
The precise extension method will depend on the language technology available.
\on{More to say here?}

\on{Other future directions?}

\ac{As a side note.
Technically we have access to the raised exception just when initially opening the debugger.
Any step over action for example could lead to another exception being raises.
The standard behaviour in Pharo is to always open the debugger on an exception.
The default one is OupsNullException, but also in case an exception was explicitly raised doing a step into for example, changes the exception to the default one.
I think we should more or less also do that.
Currently we never change the exception that was raised in the debugger, even if when stepping we get another one.
Just we can extend that with the notion of the last “real” exception that was raised, and a history of exceptions raised in that debugging session.
Like that we could have step actions/view added by an exception that can be use as long as another explicit exception was not raised.}

% ============================================================
\section{Related work}\label{sec:related}

\todo{Need more references and especially more recent ones.}

Early debuggers provided a command-line interface to inspect and step through the execution of a running program or a \emph{post mortem} ``core dump.''
With the advent of GUI-based IDEs, debuggers were also updated to offer interactive views to explore the execution state of a program and to step through its execution~\cite{Rose96a}.


% Debugging behavior
Studies of developer debugging behavior have shown that many developers have difficulty using debuggers and often shy away from them.
% Debugging: a review of the literature from an educational perspective
``We note, however, that our experiences with debugging tools is that many of them use execution traces as a method of assisting students to understand the execution of a program. Tubaishat~\cite{Tuba01a} characterized the use of execution traces as an example of a shallow reasoning technique''~\cite{McCa08a}.
% On the Dichotomy of Debugging Behavior Among Programmers
``Debuggers are difficult to use. Another reason given by interviewees, even though seasoned engineers, was that `the debugger is a complicated beast' (I2) and that `debuggers that are available now are certainly not friendly tools and they don't lend toward self-exploration.'''
\cite{Bell18a}

% Extensible debuggers
% A Simple and Extensible Graphical Debugger
An early example of an extensible debugger is \deet~\cite{Hans97a}.
Extensions to \deet were written Tcl/Tk or the Korn shell.
The focus of the extension mechanism in \deet is on adding new debugger features, rather than providing debugging support for specific application contexts.

% Extensible Debugger Framework for Extensible Languages
mbeddr~\cite{Voel17a} is a collection of languages and language extensions, mainly focusing on C, built with the Jetbrains MPS language workbench.
mbeddr includes an extensible debugger framework~\cite{Pavl15a} that focuses on providing support for the individual language extension, not application specific customizations.

% DSL Debugger extensions
There have been numerous efforts to develop specialized debuggers for domain-specific languages (DSLs) using a variety of approaches.
%  Grammar-Driven Generation of Domain-Specific Language Debuggers
Wu \etal report on grammar-driven generation of DSL debuggers~\cite{HuiW08a}.
% Declaratively Defining Domain-Specific Language Debuggers
Lindeman \etal leverage the Spoofax language workbench~\cite{Kats10a} declaratively defined DSL debuggers~\cite{Lind11a}.
% D2X: An eXtensible conteXtual Debugger for Modern DSLs
D2X~\cite{Brah23a} provides an API for DSLs to provide debugger extensions.
All of these DSL debugger approaches focus on providing general debugging for a given DSL, not for more finely-grained application debugging issues.

% Moldable tools
The Moldable Debugger~\cite{Chis15c} is an example of a ``moldable tool''~\cite{Chis17a} that adapts its behavior to a specific run-time application context.
The original moldable debugger, however, still required some significant implementation effort to define an alternative debugger, much as the other approaches we have cited from literature.
Similarly, the original Moldable Inspector~\cite{Chis15a} did not offer a very easy mechanism to provide custom inspector views depending on the object being inspected.
Very quickly, however, the extension mechanism of using annotated methods to define inspector customizations was adopted and led to a large number of custom inspector views in the current version of \GT (over 3000 at last count).

% Historical
% Disciplined Exceptions
Disciplined use of exceptions is a well-established practice in object-oriented software development~\cite{Meye88a}.
The key insight and original contribution of this paper is to leverage exceptions as the hook to molding the behavior of the debugger.
No previous approach to extensible debuggers, including the original moldable debugger, has taken this approach.

\ac{One argument reviewer B can bring :)), is that that exceptions are bad and should be avoided.
We can also emphasize that when working with frameworks having dedicated exceptions can help developers understand what is happening.
Users will not be exposed to exceptions, but developers need to reason about them.
And if they can help, developers can actually have a bigger incentive to create custom exceptions.}

% ============================================================
\section{Conclusion}\label{sec:conclusion}

Debuggers are unloved beasts.
They provide a generic and clumsy interface to explore and debug the run-time state of a running program.
Many debugging problems can be better attacked by understanding the nature of the exception that was raised and caused the debugger to be activated.
Our key contribution is to show how a debugger can be dynamically ``molded'' with custom views and actions that depend on the specific exception raised.
The mechanism is lightweight, and many useful extensions can be defined with minimal implementation effort.

\todo{What more to say?}

%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section).
%\begin{acks}
%To Robert, for the bagels and explaining CMYK and color spaces.
%\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{moldableExceptions}


\end{document}
\endinput


\begin{inparaenum}[(i)]
	\item ...
\end{inparaenum}    
